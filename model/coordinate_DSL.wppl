// target towers (hand-encoded into speaker's DSL)
var L_tower = ["h", ["l", 2], "v", "v", ["r", 2], 'h']
var L_tower_reduced = ["new_chunk1"]
var pi_tower = ["v", "v", ["r", 4], "v", "v"]
var pi_tower_reduced = ["new_chunk2"]

var lexemes = ['make an L.', 'make a PI.']
var baseLexicon = {
  'h' : 'place a horizontal block.',
  'v' : 'place a vertical block.',
  'l' : 'move left by',
  'r' : 'move right by'
}

// extend starting lexicon to include (uncertain) mapping for new DSL primitives
var lexiconPrior = function() {
  return extend(baseLexicon, {
    'new_chunk1' : uniformDraw(lexemes),
    'new_chunk2' : uniformDraw(lexemes),
  })
}

// recursively parse expressions written in DSL into language
var parseDSL = function(e, lexicon) {
  if(_.isArray(e)) {
    return reduce(function(val, rst) {
      return parseDSL(val, lexicon) + ' ' + rst
    }, '', e)
  } else if (_.has(lexicon, e)) {
    return lexicon[e]
  } else if (_.isNumber(e)) {
    return e + '.'
  }
}

// parse expressions written in language back to own DSL
var parseLanguage = function(e, lexicon) {
  var invertedLexicon = _.invert(lexicon)
  var invertedStr = reduce(function(phrase, rst) {
    return rst.replaceAll(phrase, invertedLexicon[phrase])
  }, e, _.values(lexicon))
  return invertedStr.trim().split(/[.\s]+/g)
}

// compute lexicon posterior, taking into account some previous observations
// speakers do this by assuming data came from knowledgable listener, and vice versa
var lexiconPosterior = function(originAgent, data) {
  return Infer({method: 'enumerate'}, function() {
    var lexicon = lexiconPrior();

    // enforce mutual exclusivity (i.e. no two chunks map to same word)
    condition(_.uniq(_.values(lexicon)).length
              == lexemes.length + _.values(baseLexicon).length)

    // loop through data from previous rounds, condition on data from partner
    mapData({data: data}, function(datum){
      if(originAgent === 'B') 
        factor(_.isEqual(parseDSL(datum.target, lexicon), datum.utt) ? 0 : -10)
      else if(originAgent === 'A') 
        factor(_.isEqual(parseLanguage(datum.utt, lexicon), datum.response)? 0 : -10)
    });
    return lexicon;
  });
};

// conventional builder (L0, marginalizing over lexicons)
var Builder = function(utt, data) {
  return Infer({method:"enumerate"}, function(){
    var lexicon = sample(lexiconPosterior('B', data));
    return parseLanguage(utt, lexicon);
  });
};

// conventional Architect (S1, reasoning about expected L1 behavior across lexicons)
var Architect = cache(function(state, data) {
  return Infer({method:"enumerate"}, function(){
    var lexicon = sample(lexiconPosterior('A', data));
    return parseDSL(state, lexicon);
  });
});

var step = function(remainingTrials, prevData) {
  if(remainingTrials.length == 0) 
    return prevData;
  var currTrial = first(remainingTrials)
  var target = currTrial.target;
  var utt = sample(Architect(target, prevData));
  var response = sample(Builder(utt, prevData));
  var newDatum = {utt, response, target};
  return step(rest(remainingTrials), prevData.concat(newDatum));
};

//print()
//parseLanguage(parseDSL(L, baseLexicon), baseLexicon)
var trialSequence = [
  {target: L_tower},
  {target: pi_tower},
  {target: L_tower_reduced},
  {target: pi_tower_reduced},
  {target: L_tower_reduced},
  {target: pi_tower_reduced},
  {target: L_tower_reduced},
  {target: pi_tower_reduced},
]
JSON.stringify(step(trialSequence, []), null,'\t');
