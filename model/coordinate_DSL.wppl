// target towers (hand-encoded into speaker's DSL)
// var L_tower = ["h", ["l", 2], "v", "v", ["r", 2], 'h']
// var L_tower_reduced = ["new_chunk1"]
// var pi_tower = ["v", "v", ["r", 4], "v", "v"]
// var pi_tower_reduced = ["new_chunk2"]

var trialSequence = json.read('./synthesis_data/ca_synthesis_output_manual_edit.json');
var totalNumInstructions = reduce(function(trial, rest) {
  return rest + trial.sceneProgram.split(' ').length;
}, 0, trialSequence);
var numInstructionsPerTrial = map(function(trial) {
  return trial.sceneProgram.split(' ').length;
}, trialSequence);

var lexemes = ['blah', 'blab', 'bloop', 'bleep'];

var makeObject = function(key, value) {
  return _.zipObject([key], [value]);
};

// extend starting lexicon to include (uncertain) mapping for new DSL primitives
var lexiconPrior = function(dsl) {
  var baseLexicon = {
    'h' : 'place a horizontal block.',
    'v' : 'place a vertical block.',
  };
  return reduce(function(item, rest) {
    var newItem = (
      item[0] == 'r' ?
        makeObject(item, 'move to the right by ' + item.split('_')[1]) :
        item[0] == 'l' ? 
        makeObject(item, 'move to the left by ' + item.split('_')[1]) :
        makeObject(item, sample(Categorical({vs: lexemes})))
    );
    return extend(rest, newItem);
  }, baseLexicon, dsl.slice(2));
}

// recursively parse expressions written in DSL into language
var parseDSL = function(e, lexicon) {
  return lexicon[e];
};

// parse expressions written in language back to own DSL
var parseLanguage = function(language, lexicon) {
  return _.invert(lexicon)[language];
};

// compute lexicon posterior, taking into account some previous observations
// speakers do this by assuming data came from knowledgable listener, and vice versa
var lexiconPosterior = function(originAgent, dsl, data) {
  return Infer({method: 'enumerate'}, function() {
    var lexicon = lexiconPrior(dsl);

    // enforce mutual exclusivity (i.e. no two chunks map to same word)
    condition(_.uniq(_.values(lexicon)).length == dsl.length);
    
    // loop through data from previous rounds, condition on data from partner
    mapData({data: data}, function(datum){      
      if(originAgent === 'B') {
        factor(_.isEqual(parseDSL(datum.targetInstruction, lexicon), datum.utt) ? 0 : -3);
      } else if(originAgent === 'A') {
        factor(_.isEqual(parseLanguage(datum.utt, lexicon), datum.response)? 0 : -3);
      }
    });
    return lexicon;
  });
};

// conventional builder (L0, marginalizing over lexicons)
var Builder = function(utt, state, prevData) {
  return Infer({method:"enumerate"}, function(){
    var lexicon = sample(lexiconPosterior('B', state.dsl, prevData));
    return parseLanguage(utt, lexicon);
  });
};

// conventional Architect (S1, reasoning about expected L1 behavior across lexicons)
var Architect = cache(function(target, state, prevData) {
  return Infer({method:"enumerate"}, function(){
    var lexicon = sample(lexiconPosterior('A', state.dsl, prevData));
    return parseDSL(target, lexicon);
  });
});

var step = function(remainingTrials, prevData) {
  if(remainingTrials.length == 0) 
    return prevData;
  var currTrial = first(remainingTrials);
  var target = currTrial.sceneProgram;
  var newData = map(function(targetInstruction) {
    var speakerDist = Architect(targetInstruction, currTrial, prevData);
    var utt = sample(speakerDist);
    var listenerDist = Builder(utt, currTrial, prevData);
    var response = sample(listenerDist);
    return {utt, response, targetInstruction,
            correct: response == targetInstruction};
  }, target.split(' '));
  return step(rest(remainingTrials), prevData.concat(newData));
};

var runs = Infer({method: 'forward', samples: 100}, function() {
  console.log('running');
  var output = step(trialSequence, []);
  return map(function(instruction) {return instruction.correct;}, output);
});

map(function(instructionNum) {
  console.log(
    'instruction #' + instructionNum + ':',
    expectation(runs, function(run) {return run[instructionNum];})
  );
}, _.range(totalNumInstructions));
''
//console.log('last trial', expectation(runs, function(run) {return run[-1]}))


//, null,'\t');
